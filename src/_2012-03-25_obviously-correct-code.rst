==================
编写显然正确的代码
==================

:author: yihuang
:email: yi.codeplayer@gmail.com
:blog: http://yi-programmer.com/
:github: http://github.com/yihuang

代码质量的两个方面
==================

* 抽象

* 健壮

抽象的标准：贴合自然语言
========================

::

    机器 -|---|-----------------------|---- 人类
         汇编 C                    Haskell  自然语言

抽象的标准：组合能力
====================

TODO

抽象与性能
==========

* cons: 程序代码与执行代码之间不够透明

* pros: 编译器拥有更多的代码优化的手段

* pros: 更好的profile工具

* pros: 程序并行化等其他手动很难控制的优化

Haskell：为代码洁癖们准备的语言
===============================

* 纯函数式

* 惰性求值

* 高级静态类型系统

函数定义以及调用 - 快速科普一下
===============================

TODO 代码需要一部分一部分进行解释，还需要更好的工具处理得更直观一点。

::

  add :: Int -> Int -> Int

  > add 1 2
  3

操作符 - 以符号命名的函数
=========================

::

  (+) :: Int -> Int -> Int

  > (+) 1 2
  3

中缀形式 - 让二元函数更直观
==========================

::

  > 1 + 2
  3

  > 1 `add` 2
  3

Curry和Section - DRY的诀窍
==========================

::

  > :t add 1
  Int -> Int

  > let f = add 1
  > f 2
  3

Curry和Section - DRY的诀窍
==========================

::

  > :t (1+)
  Int -> Int
  > (1+) 2
  3

高阶函数 - FP世界的基石
=======================

::

  > :t map
  (a -> b) -> [a] -> [b]
  > :t filter
  (a -> Bool) -> [a] -> [a]
  > :t concat
  [[a]] -> [a]

(.) - FP世界的管道
==================

::

  (.) :: (b -> c) -> (a -> b) -> a -> c
  (f . g) x = f (g x)

感受组合的能力
==============

::

  > ((+1) . length) "hello"
  6
  > filter ((==0) . (`mod` 2)) [1..10]
  [1,3,5,7,9]

Case study - 把它们拼起来
=========================

来自微博的问题：

 找出一个锯齿数组里长度大于5的子数组
 在符合要求的子数组里的数据里找出所有偶数
 如果数据小于10的话乘以2,大于10的除以2
 最后统计符合要求的数据的和

Case study - 把它们拼起来
=========================

TODO 需要更直观地展示每一步数据转换的过程，以及与自然语言描述的对应。

::

  sum' = sum
         . map (\x -> if x<10 then x*2 else x `div` 2)
         . filter ((==0) . (`mod` 2))
         . concat
         . filter ((>5) . length)

Core Syntax - Haskell语法内核
=============================

TODO 这是我学Haskell过程第一个让我决定学完Haskell的理由。

看看优化后的代码
================

TODO 展示上面示例经过编译器优化处理之后的代码，说明抽象与性能可以兼得。

健壮 - 终有一天我们能够信任我们的软件
=====================================

* 始终保持精确

* 机器自动保证

静态类型系统
============

TODO 图表 (正确的程序 与 类型正确的程序 之间的交集)

Case study - lookup
===================

::

    lookup :: k -> Map k v -> ?

假想
====

::

    lookup :: k -> Map k v -> v
    process :: v -> something

    > process (lookup k m)
    **crash**

Case study - lookup
===================

::

    lookup :: k -> Map k v -> Maybe v

Maybe - 总有些事情是我们没有把握的
==================================

::

  data Maybe a = Just a | Nothing

TODO 如何介绍代数数据类型，介绍到哪个程度

Maybe - 总有些事情是我们没有把握的
==================================

TODO some maybe usage.

::

  > fromMaybe 0 (lookup 'a' [])
  0

抽象(续) - Monad
=================

TODO

GHC - 工业级Haskell实现
=======================

* 强大的代码优化能力

* 眼花缭乱的高级类型系统扩展

* 完美 M-N 微线程实现和线程同步机制

* 基于微线程的IO

* 强大的并行支持

第三方库
========

* TODO

Haskell并非完美
===============

* record语法还有待完善

* 调试以及性能评估

Q & A
======
